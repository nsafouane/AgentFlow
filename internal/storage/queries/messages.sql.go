// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: messages.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createMessage = `-- name: CreateMessage :one
INSERT INTO messages (id, tenant_id, trace_id, span_id, from_agent, to_agent, type, payload, metadata, cost, ts, envelope_hash)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
RETURNING id, tenant_id, trace_id, span_id, from_agent, to_agent, type, payload, metadata, cost, ts, envelope_hash
`

type CreateMessageParams struct {
	ID           pgtype.UUID        `json:"id"`
	TenantID     pgtype.UUID        `json:"tenant_id"`
	TraceID      pgtype.Text        `json:"trace_id"`
	SpanID       pgtype.Text        `json:"span_id"`
	FromAgent    string             `json:"from_agent"`
	ToAgent      string             `json:"to_agent"`
	Type         string             `json:"type"`
	Payload      []byte             `json:"payload"`
	Metadata     []byte             `json:"metadata"`
	Cost         []byte             `json:"cost"`
	Ts           pgtype.Timestamptz `json:"ts"`
	EnvelopeHash string             `json:"envelope_hash"`
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (Message, error) {
	row := q.db.QueryRow(ctx, createMessage,
		arg.ID,
		arg.TenantID,
		arg.TraceID,
		arg.SpanID,
		arg.FromAgent,
		arg.ToAgent,
		arg.Type,
		arg.Payload,
		arg.Metadata,
		arg.Cost,
		arg.Ts,
		arg.EnvelopeHash,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.TraceID,
		&i.SpanID,
		&i.FromAgent,
		&i.ToAgent,
		&i.Type,
		&i.Payload,
		&i.Metadata,
		&i.Cost,
		&i.Ts,
		&i.EnvelopeHash,
	)
	return i, err
}

const deleteMessage = `-- name: DeleteMessage :exec
DELETE FROM messages
WHERE id = $1 AND tenant_id = $2
`

type DeleteMessageParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) DeleteMessage(ctx context.Context, arg DeleteMessageParams) error {
	_, err := q.db.Exec(ctx, deleteMessage, arg.ID, arg.TenantID)
	return err
}

const getMessage = `-- name: GetMessage :one
SELECT id, tenant_id, trace_id, span_id, from_agent, to_agent, type, payload, metadata, cost, ts, envelope_hash FROM messages
WHERE id = $1 AND tenant_id = $2
`

type GetMessageParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetMessage(ctx context.Context, arg GetMessageParams) (Message, error) {
	row := q.db.QueryRow(ctx, getMessage, arg.ID, arg.TenantID)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.TraceID,
		&i.SpanID,
		&i.FromAgent,
		&i.ToAgent,
		&i.Type,
		&i.Payload,
		&i.Metadata,
		&i.Cost,
		&i.Ts,
		&i.EnvelopeHash,
	)
	return i, err
}

const listMessagesByAgent = `-- name: ListMessagesByAgent :many
SELECT id, tenant_id, trace_id, span_id, from_agent, to_agent, type, payload, metadata, cost, ts, envelope_hash FROM messages
WHERE tenant_id = $1 AND (from_agent = $2 OR to_agent = $2)
ORDER BY ts DESC
LIMIT $3 OFFSET $4
`

type ListMessagesByAgentParams struct {
	TenantID  pgtype.UUID `json:"tenant_id"`
	FromAgent string      `json:"from_agent"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

func (q *Queries) ListMessagesByAgent(ctx context.Context, arg ListMessagesByAgentParams) ([]Message, error) {
	rows, err := q.db.Query(ctx, listMessagesByAgent,
		arg.TenantID,
		arg.FromAgent,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Message{}
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.TraceID,
			&i.SpanID,
			&i.FromAgent,
			&i.ToAgent,
			&i.Type,
			&i.Payload,
			&i.Metadata,
			&i.Cost,
			&i.Ts,
			&i.EnvelopeHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMessagesByTenant = `-- name: ListMessagesByTenant :many
SELECT id, tenant_id, trace_id, span_id, from_agent, to_agent, type, payload, metadata, cost, ts, envelope_hash FROM messages
WHERE tenant_id = $1
ORDER BY ts DESC
LIMIT $2 OFFSET $3
`

type ListMessagesByTenantParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

func (q *Queries) ListMessagesByTenant(ctx context.Context, arg ListMessagesByTenantParams) ([]Message, error) {
	rows, err := q.db.Query(ctx, listMessagesByTenant, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Message{}
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.TraceID,
			&i.SpanID,
			&i.FromAgent,
			&i.ToAgent,
			&i.Type,
			&i.Payload,
			&i.Metadata,
			&i.Cost,
			&i.Ts,
			&i.EnvelopeHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMessagesByTimeRange = `-- name: ListMessagesByTimeRange :many
SELECT id, tenant_id, trace_id, span_id, from_agent, to_agent, type, payload, metadata, cost, ts, envelope_hash FROM messages
WHERE tenant_id = $1 AND ts BETWEEN $2 AND $3
ORDER BY ts DESC
LIMIT $4 OFFSET $5
`

type ListMessagesByTimeRangeParams struct {
	TenantID pgtype.UUID        `json:"tenant_id"`
	Ts       pgtype.Timestamptz `json:"ts"`
	Ts_2     pgtype.Timestamptz `json:"ts_2"`
	Limit    int32              `json:"limit"`
	Offset   int32              `json:"offset"`
}

func (q *Queries) ListMessagesByTimeRange(ctx context.Context, arg ListMessagesByTimeRangeParams) ([]Message, error) {
	rows, err := q.db.Query(ctx, listMessagesByTimeRange,
		arg.TenantID,
		arg.Ts,
		arg.Ts_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Message{}
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.TraceID,
			&i.SpanID,
			&i.FromAgent,
			&i.ToAgent,
			&i.Type,
			&i.Payload,
			&i.Metadata,
			&i.Cost,
			&i.Ts,
			&i.EnvelopeHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMessagesByTrace = `-- name: ListMessagesByTrace :many
SELECT id, tenant_id, trace_id, span_id, from_agent, to_agent, type, payload, metadata, cost, ts, envelope_hash FROM messages
WHERE tenant_id = $1 AND trace_id = $2
ORDER BY ts ASC
`

type ListMessagesByTraceParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	TraceID  pgtype.Text `json:"trace_id"`
}

func (q *Queries) ListMessagesByTrace(ctx context.Context, arg ListMessagesByTraceParams) ([]Message, error) {
	rows, err := q.db.Query(ctx, listMessagesByTrace, arg.TenantID, arg.TraceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Message{}
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.TraceID,
			&i.SpanID,
			&i.FromAgent,
			&i.ToAgent,
			&i.Type,
			&i.Payload,
			&i.Metadata,
			&i.Cost,
			&i.Ts,
			&i.EnvelopeHash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
