// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: audits.sql

package queries

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAudit = `-- name: CreateAudit :one
INSERT INTO audits (tenant_id, actor_type, actor_id, action, resource_type, resource_id, details, prev_hash, hash)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
RETURNING id, tenant_id, actor_type, actor_id, action, resource_type, resource_id, details, ts, prev_hash, hash
`

type CreateAuditParams struct {
	TenantID     pgtype.UUID `json:"tenant_id"`
	ActorType    string      `json:"actor_type"`
	ActorID      string      `json:"actor_id"`
	Action       string      `json:"action"`
	ResourceType string      `json:"resource_type"`
	ResourceID   pgtype.Text `json:"resource_id"`
	Details      []byte      `json:"details"`
	PrevHash     []byte      `json:"prev_hash"`
	Hash         []byte      `json:"hash"`
}

func (q *Queries) CreateAudit(ctx context.Context, arg CreateAuditParams) (Audit, error) {
	row := q.db.QueryRow(ctx, createAudit,
		arg.TenantID,
		arg.ActorType,
		arg.ActorID,
		arg.Action,
		arg.ResourceType,
		arg.ResourceID,
		arg.Details,
		arg.PrevHash,
		arg.Hash,
	)
	var i Audit
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ActorType,
		&i.ActorID,
		&i.Action,
		&i.ResourceType,
		&i.ResourceID,
		&i.Details,
		&i.Ts,
		&i.PrevHash,
		&i.Hash,
	)
	return i, err
}

const getAudit = `-- name: GetAudit :one
SELECT id, tenant_id, actor_type, actor_id, action, resource_type, resource_id, details, ts, prev_hash, hash FROM audits
WHERE id = $1 AND tenant_id = $2
`

type GetAuditParams struct {
	ID       pgtype.UUID `json:"id"`
	TenantID pgtype.UUID `json:"tenant_id"`
}

func (q *Queries) GetAudit(ctx context.Context, arg GetAuditParams) (Audit, error) {
	row := q.db.QueryRow(ctx, getAudit, arg.ID, arg.TenantID)
	var i Audit
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ActorType,
		&i.ActorID,
		&i.Action,
		&i.ResourceType,
		&i.ResourceID,
		&i.Details,
		&i.Ts,
		&i.PrevHash,
		&i.Hash,
	)
	return i, err
}

const getAuditChain = `-- name: GetAuditChain :many
SELECT id, tenant_id, actor_type, actor_id, action, resource_type, resource_id, details, ts, prev_hash, hash FROM audits
WHERE tenant_id = $1
ORDER BY ts ASC
`

func (q *Queries) GetAuditChain(ctx context.Context, tenantID pgtype.UUID) ([]Audit, error) {
	rows, err := q.db.Query(ctx, getAuditChain, tenantID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Audit{}
	for rows.Next() {
		var i Audit
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ActorType,
			&i.ActorID,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.Details,
			&i.Ts,
			&i.PrevHash,
			&i.Hash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestAudit = `-- name: GetLatestAudit :one
SELECT id, tenant_id, actor_type, actor_id, action, resource_type, resource_id, details, ts, prev_hash, hash FROM audits
WHERE tenant_id = $1
ORDER BY ts DESC
LIMIT 1
`

func (q *Queries) GetLatestAudit(ctx context.Context, tenantID pgtype.UUID) (Audit, error) {
	row := q.db.QueryRow(ctx, getLatestAudit, tenantID)
	var i Audit
	err := row.Scan(
		&i.ID,
		&i.TenantID,
		&i.ActorType,
		&i.ActorID,
		&i.Action,
		&i.ResourceType,
		&i.ResourceID,
		&i.Details,
		&i.Ts,
		&i.PrevHash,
		&i.Hash,
	)
	return i, err
}

const listAuditsByActor = `-- name: ListAuditsByActor :many
SELECT id, tenant_id, actor_type, actor_id, action, resource_type, resource_id, details, ts, prev_hash, hash FROM audits
WHERE tenant_id = $1 AND actor_type = $2 AND actor_id = $3
ORDER BY ts DESC
LIMIT $4 OFFSET $5
`

type ListAuditsByActorParams struct {
	TenantID  pgtype.UUID `json:"tenant_id"`
	ActorType string      `json:"actor_type"`
	ActorID   string      `json:"actor_id"`
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
}

func (q *Queries) ListAuditsByActor(ctx context.Context, arg ListAuditsByActorParams) ([]Audit, error) {
	rows, err := q.db.Query(ctx, listAuditsByActor,
		arg.TenantID,
		arg.ActorType,
		arg.ActorID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Audit{}
	for rows.Next() {
		var i Audit
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ActorType,
			&i.ActorID,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.Details,
			&i.Ts,
			&i.PrevHash,
			&i.Hash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditsByResource = `-- name: ListAuditsByResource :many
SELECT id, tenant_id, actor_type, actor_id, action, resource_type, resource_id, details, ts, prev_hash, hash FROM audits
WHERE tenant_id = $1 AND resource_type = $2 AND resource_id = $3
ORDER BY ts DESC
LIMIT $4 OFFSET $5
`

type ListAuditsByResourceParams struct {
	TenantID     pgtype.UUID `json:"tenant_id"`
	ResourceType string      `json:"resource_type"`
	ResourceID   pgtype.Text `json:"resource_id"`
	Limit        int32       `json:"limit"`
	Offset       int32       `json:"offset"`
}

func (q *Queries) ListAuditsByResource(ctx context.Context, arg ListAuditsByResourceParams) ([]Audit, error) {
	rows, err := q.db.Query(ctx, listAuditsByResource,
		arg.TenantID,
		arg.ResourceType,
		arg.ResourceID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Audit{}
	for rows.Next() {
		var i Audit
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ActorType,
			&i.ActorID,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.Details,
			&i.Ts,
			&i.PrevHash,
			&i.Hash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAuditsByTenant = `-- name: ListAuditsByTenant :many
SELECT id, tenant_id, actor_type, actor_id, action, resource_type, resource_id, details, ts, prev_hash, hash FROM audits
WHERE tenant_id = $1
ORDER BY ts DESC
LIMIT $2 OFFSET $3
`

type ListAuditsByTenantParams struct {
	TenantID pgtype.UUID `json:"tenant_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

func (q *Queries) ListAuditsByTenant(ctx context.Context, arg ListAuditsByTenantParams) ([]Audit, error) {
	rows, err := q.db.Query(ctx, listAuditsByTenant, arg.TenantID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Audit{}
	for rows.Next() {
		var i Audit
		if err := rows.Scan(
			&i.ID,
			&i.TenantID,
			&i.ActorType,
			&i.ActorID,
			&i.Action,
			&i.ResourceType,
			&i.ResourceID,
			&i.Details,
			&i.Ts,
			&i.PrevHash,
			&i.Hash,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
